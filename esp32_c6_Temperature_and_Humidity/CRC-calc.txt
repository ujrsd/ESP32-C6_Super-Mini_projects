5F = 0101 1111
10 = 0001 0000
BC = 1011 1100

Polynom: 0x31 = x^8 + x^5 + x^4 + 1 = 100110001

0101 1111 0001 0000 1011 1100 / 100110001 =
 100 1100 01

   1 0011 0101 0000 1011 1100
   1 0011 0001

           100 0000 1011 1100
           100 1100 01
               1100 1111 1100
               1001 1000 1
                101 0111 0100
                100 1100 01
                  1 1011 0000
                  1 0011 0001
                    1000 0001

010111110001000010111100 / 100110001 =
 100110001
000100110101000010111100
   100110001
000000000100000010111100
         100110001
000000000000110011111100
            100110001
000000000000010101110100
             100110001
000000000000000110110000
               100110001

1010 = A
1011 = B
1100 = C
1101 = D
1110 = E
1111 = F

Example from Datasheet:
CRC-8, init is 0xFF, final XOR 0x00, Polynomial 0x31
CRC(0xBEEF) = 0x92

0xBEEF = 
1011111011101111 00000000 with 0xFF init
0100000111101111 00000000 / 100110001
 100110001
    110110101111 00000000
    100110001
     10000100111 00000000
     100110001
        11100011 00000000
        10011000 1
         1111011 10000000
         1001100 01
	  110111 11000000
          100110 001
	   10001 11100000
           10011 0001
	      10 11110000
              10 0110001
	         10010010
               1 00110001 > 1001 0010 = 0x92

Algorithm:

0. Values to obtain from sensor: MSB Byte 1, LSB Byte 2 and Checksum of CRC
   and Polynomial 0x31 = x^8 + x^5 + x^4 + 1 = 1 0011 0001
   and Initialization: 0xFF and Final XOR 0x00 and Reflect I/O false/false
1. Do calculation: Byte 1 XOR Initialization
2. Add padding of 8-Bits which are 0, because Polynomial is a 9-bit value
3. Do Polynomial division until remainder is reached -> as soon as left over
   value is smaller as the divisor.
4. If result is equal to the recieved CRC-Checksum of the sensor -> Data is valid
   Elswise, scrap data
